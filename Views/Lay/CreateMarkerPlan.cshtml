  @model CutUsage.Models.MarkerPlanCreateViewModel
@using Newtonsoft.Json
@{
    ViewData["Title"] = "Create Marker Plan";
    var styles = ViewBag.Styles as List<CutUsage.Models.StyleM>
                 ?? new List<CutUsage.Models.StyleM>();
}
@section Styles {
    <style>
        /* hide number‐input spinners in Chrome, Safari, Edge */
        input[type=number]::-webkit-inner-spin-button,
        input[type=number]::-webkit-outer-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        /* hide number‐input spinners in Firefox */
        input[type=number] {
            -moz-appearance: textfield;
        }

        /* 1) Target *your* wrapper (#matrixContainer), *not* the old #buildPlanMatrixContainer */
        #matrixContainer table {
            font-size: .75rem;
        }

        /* 2) Make Marker Name at least 20 characters wide */
        #matrixContainer th.marker-name-col,
        #matrixContainer .marker-name-input {
            min-width: 20ch;
            /* or if you want a fixed width: width: 20ch; */
        }

        /* 3) Tighter numeric columns (adjust the nth‐of‐type indexes as needed) */
        /* e.g. “No of Plies” is column 10, “Total Size Count” is 11: */
        #matrixContainer th:nth-of-type(10),
        #matrixContainer td:nth-of-type(10),
        #matrixContainer th:nth-of-type(11),
        #matrixContainer td:nth-of-type(11) {
            min-width: 6ch;
            text-align: center;
        }

        /* 4) Allowance + totals can be a bit wider */
        #matrixContainer .allowance-input,
        #matrixContainer .fabric-req-cell,
        #matrixContainer .marker-usage-cell,
        #matrixContainer .marker-saving-cell,
        #matrixContainer .target-length-cell {
            min-width: 8ch;
            text-align: right;
        }

        /* 5) Header styling */
        .table-striped thead th {
            background-color: #f8f9fa;
        }

        .table-hover tbody tr:hover {
            background-color: rgba(0,123,255,.05);
        }

    </style>
}
<h2>@ViewData["Title"]</h2>

<div asp-validation-summary="All" class="text-danger mb-3"></div>
@* <div class="alert alert-info">
    <p>
        This form allows you to create a marker plan by selecting a style, associated sales orders (SO), and dockets.
        After selection, a matrix will be generated where you can input marker details.
    </p>
    <p>
        The matrix will automatically calculate fabric requirements, marker usage, savings, and target lengths based on your inputs.
    </p>
    <p>
        Use the "Reset Table" button to clear the matrix inputs and computed cells, or "Reset All" to clear the entire form.
    </p>
</div> *@

@* 1) ValidationSummary for DataAnnotations *@
<div asp-validation-summary="All" class="text-danger mb-3"></div>

@* 2) Explicit list of binding/conversion errors *@
@if (ViewBag.BindErrors is List<dynamic> errs && errs.Any())
{
    <div class="alert alert-danger">
        <strong>Binding errors:</strong>
        <ul>
            @foreach (var e in errs)
            {
                <li>@e.Field: @e.Message</li>
            }
        </ul>
    </div>
}
<form id="planForm" class="mb-4" method="post" asp-action="CreateMarkerPlan">
    <div class="row g-3 mb-3">
<div class="col-12 col-md-3">
  <label for="styleSelect" class="form-label">Select Style(s)</label>
  <select id="styleSelect"
          name="SelectedStyles"
          class="form-select"
          multiple>
    @using CutUsage.Models  @* make sure you have this *@
@foreach (var st in (List<StyleM>)ViewBag.Styles)
{
    if (Model.SelectedStyles?.Contains(st.Style) == true)
    {
        <option value="@st.Style" selected="selected">@st.Style</option>
    }
    else
    {
        <option value="@st.Style">@st.Style</option>
    }
}
  </select>
</div>

        <div class="col-12 col-md-3">
            <label for="soSelect" class="form-label">Select SO(s)</label>
            <select id="soSelect"
                    name="SelectedSO"
                    class="form-select"
                    multiple
                    disabled>
            </select>
        </div>

        <div class="col-12 col-md-3">
            <label for="docketSelect" class="form-label">Select Docket(s)</label>
            <select id="docketSelect"
                    name="SelectedDocket"
                    class="form-select"
                    multiple
                    disabled>
            </select>
        </div>
        <div class="col-12 col-md-3">
            <div class="col-12 col-md-12">
                <button type="button"
                        id="resetTableBtn"
                        class="btn btn-secondary w-100">
                    Reset Table
                </button>
            </div>
            <br />
            <div class="col-12 col-md-12">
                <button type="button"
                        id="resetAllBtn"
                        class="btn btn-warning w-100">
                    Reset All
                </button>
            </div>
            <br />
            <div class="col-12 col-md-12">
                <button type="submit" class="btn btn-primary w-100">Save Plan</button>
            </div>

        </div>
    </div>

    @* Mirror selected arrays as hidden inputs for post-back *@
    @if (Model.SelectedSO != null)
    {
        foreach (var so in Model.SelectedSO)
        {
            <input type="hidden" name="SelectedSO" value="@so" />
        }
    }
    @if (Model.SelectedDocket != null)
    {
        foreach (var d in Model.SelectedDocket)
        {
            <input type="hidden" name="SelectedDocket" value="@d" />
        }
    }

    <div id="matrixContainer">
        @* Partial view will be injected here *@
    </div>


</form>

@section Scripts {
  <script>
    // ELEMENT REFS (note styleSelect, not styleInput)
    const styleEl      = document.getElementById('styleSelect'),
          soEl         = document.getElementById('soSelect'),
          dockEl       = document.getElementById('docketSelect'),
          matrixCt     = document.getElementById('matrixContainer'),
          resetTableBtn = document.getElementById('resetTableBtn'),
          resetAllBtn   = document.getElementById('resetAllBtn'),
          formEl        = document.getElementById('planForm');

    // A simple cache so we can restore inputs when the matrix re-renders
    const matrixCache = {
      ratios: {}, plies: {},
      markerNames: {}, lengths: {},
      widths: {}, allowances: {},
      docketTotals: {}, rowTotals: {},
      fabrics: {}, usages: {},
      savings: {}, targets: {}
    };

    function cacheMatrixValues() {
      matrixCt.querySelectorAll('.ratio-input').forEach(i => {
        matrixCache.ratios[`${i.dataset.docket}_${i.dataset.size}`] = i.value;
      });
      matrixCt.querySelectorAll('.plies-input').forEach(i => {
        matrixCache.plies[i.dataset.docket] = i.value;
      });
      matrixCt.querySelectorAll('.marker-name-input').forEach(i => {
        matrixCache.markerNames[i.dataset.docket] = i.value;
      });
      matrixCt.querySelectorAll('.marker-length-input').forEach(i => {
        matrixCache.lengths[i.dataset.docket] = i.value;
      });
      matrixCt.querySelectorAll('.marker-width-input').forEach(i => {
        matrixCache.widths[i.dataset.docket] = i.value;
      });
      matrixCt.querySelectorAll('.allowance-input').forEach(i => {
        matrixCache.allowances[i.dataset.docket] = i.value;
      });
      matrixCt.querySelectorAll('.docket-total-input').forEach(i => {
        matrixCache.docketTotals[i.dataset.docket] = i.value;
      });
      matrixCt.querySelectorAll('.row-total-size').forEach(c => {
        matrixCache.rowTotals[c.dataset.docket] = c.textContent;
      });
      matrixCt.querySelectorAll('.fabric-req-cell').forEach(c => {
        matrixCache.fabrics[c.dataset.docket] = c.textContent;
      });
      matrixCt.querySelectorAll('.marker-usage-cell').forEach(c => {
        matrixCache.usages[c.dataset.docket] = c.textContent;
      });
      matrixCt.querySelectorAll('.marker-saving-cell').forEach(c => {
        matrixCache.savings[c.dataset.docket] = c.textContent;
      });
      matrixCt.querySelectorAll('.target-length-cell').forEach(c => {
        matrixCache.targets[c.dataset.docket] = c.textContent;
      });
    }

    function restoreMatrixValues() {
      matrixCt.querySelectorAll('.ratio-input').forEach(i => {
        const key = `${i.dataset.docket}_${i.dataset.size}`;
        if (matrixCache.ratios[key] != null) i.value = matrixCache.ratios[key];
      });
      matrixCt.querySelectorAll('.plies-input').forEach(i => {
        const v = matrixCache.plies[i.dataset.docket];
        if (v != null) i.value = v;
      });
      matrixCt.querySelectorAll('.marker-name-input').forEach(i => {
        const v = matrixCache.markerNames[i.dataset.docket];
        if (v != null) {
          i.value = v;
          i.dispatchEvent(new Event('input',{ bubbles:true }));
        }
      });
      matrixCt.querySelectorAll('.marker-length-input').forEach(i => {
        const v = matrixCache.lengths[i.dataset.docket];
        if (v != null) i.value = v;
      });
      matrixCt.querySelectorAll('.marker-width-input').forEach(i => {
        const v = matrixCache.widths[i.dataset.docket];
        if (v != null) i.value = v;
      });
      matrixCt.querySelectorAll('.allowance-input').forEach(i => {
        const v = matrixCache.allowances[i.dataset.docket];
        if (v != null) i.value = v;
      });
      matrixCt.querySelectorAll('.docket-total-input').forEach(i => {
        const v = matrixCache.docketTotals[i.dataset.docket];
        if (v != null) i.value = v;
      });
      matrixCt.querySelectorAll('.row-total-size').forEach(c => {
        const v = matrixCache.rowTotals[c.dataset.docket];
        if (v != null) c.textContent = v;
      });
      matrixCt.querySelectorAll('.fabric-req-cell').forEach(c => {
        const v = matrixCache.fabrics[c.dataset.docket];
        if (v != null) c.textContent = v;
      });
      matrixCt.querySelectorAll('.marker-usage-cell').forEach(c => {
        const v = matrixCache.usages[c.dataset.docket];
        if (v != null) c.textContent = v;
      });
      matrixCt.querySelectorAll('.marker-saving-cell').forEach(c => {
        const v = matrixCache.savings[c.dataset.docket];
        if (v != null) c.textContent = v;
      });
      matrixCt.querySelectorAll('.target-length-cell').forEach(c => {
        const v = matrixCache.targets[c.dataset.docket];
        if (v != null) c.textContent = v;
      });
    }

    function clearMatrixCache() {
      Object.keys(matrixCache).forEach(k => matrixCache[k] = {});
    }

    // ENABLE disables on submit so your POST gets the selected SOs/dockets
    formEl.addEventListener('submit', () => {
      soEl.disabled   = false;
      dockEl.disabled = false;
    });

    // RESET BUTTONS
    resetTableBtn.addEventListener('click', () => {
      matrixCt.querySelectorAll('input').forEach(i => {
        i.value = (i.type==='number' ? 0 : '');
        i.dispatchEvent(new Event('input',{ bubbles:true }));
      });
      matrixCt.querySelectorAll(
        '.row-total-size,'+
        '.fabric-req-cell,'+
        '.marker-usage-cell,'+
        '.marker-saving-cell,'+
        '.target-length-cell'
      ).forEach(c => c.textContent = '0');
      document.getElementById('fabricTotalCell').textContent      = '';
      document.getElementById('markerSavingTotalCell').textContent = '';
      buildPlanMatrixInit();
      setupCentralCalculation();
      clearMatrixCache();
    });
    resetAllBtn.addEventListener('click', () => {
      styleEl.value = '';
      soEl.innerHTML   = '';
      soEl.disabled    = true;
      dockEl.innerHTML = '';
      dockEl.disabled  = true;
      matrixCt.innerHTML = '';
      clearMatrixCache();
    });

    // STYLE SELECT → load all selected SOs
    styleEl.addEventListener('change', async () => {
      const styles = [...styleEl.selectedOptions].map(o=>o.value);
      soEl.disabled   = true;
      dockEl.disabled = true;
      soEl.innerHTML   = '<option>Loading…</option>';
      dockEl.innerHTML = '';
      if (!styles.length) {
        soEl.innerHTML = '';
        return;
      }
      const qs   = styles.map(s=>`style=${encodeURIComponent(s)}`).join('&');
      const resp = await fetch(`/Lay/GetSOsByStyle?${qs}`);
      const items= await resp.json();
      soEl.innerHTML  = items.map(i=>`<option value="${i.value}">${i.text}</option>`).join('');
      soEl.disabled   = false;
    });

    // SO SELECT → load dockets (and remember any you’d already picked)
    soEl.addEventListener('change', async () => {
      const prev = [...dockEl.selectedOptions].map(o=>o.value);
      dockEl.disabled   = true;
      dockEl.innerHTML = '<option>Loading…</option>';
      const selectedSOs = [...soEl.selectedOptions].map(o=>o.value);
      if (!selectedSOs.length) {
        dockEl.innerHTML = '';
        return;
      }
      const qs   = selectedSOs.map(s=>`so=${encodeURIComponent(s)}`).join('&');
      const resp = await fetch(`/Lay/GetDocketsBySO?${qs}`);
      const items= await resp.json();
      dockEl.innerHTML = items.map(i=>`<option value="${i.value}">${i.text}</option>`).join('');
      dockEl.disabled   = false;
      // restore any old picks
      prev.forEach(v => {
        const opt = dockEl.querySelector(`option[value="${v}"]`);
        if (opt) opt.selected = true;
      });
      // fire the matrix-load if needed
      dockEl.dispatchEvent(new Event('change',{ bubbles:true }));
    });

    // DOCKET SELECT → render your partial and re-bind everything
    dockEl.addEventListener('change', async () => {
      cacheMatrixValues();
      const sos    = [...soEl.selectedOptions].map(o=>o.value),
            docs   = [...dockEl.selectedOptions].map(o=>o.value);
      if (!docs.length) {
        matrixCt.innerHTML = '';
        return;
      }
      const qs = [
        ...sos.map(s=>`so=${encodeURIComponent(s)}`),
        ...docs.map(d=>`docket=${encodeURIComponent(d)}`)
      ].join('&');
      const resp = await fetch(`/Lay/BuildPlanMatrix?${qs}`);
      matrixCt.innerHTML = await resp.text();
      restoreMatrixValues();
      buildPlanMatrixInit();
      setupPropagation();
      setupCentralCalculation();
    });

    // BUILD PLAN MATRIX — tracks ratios & plies, updates totals
    function buildPlanMatrixInit() {
      const vmScript   = document.getElementById('matrix-data'),
            vm         = vmScript ? JSON.parse(vmScript.textContent) 
                                 : { Sizes:[], QtyMap:{}, ExistingCut:{} },
            sizes      = vm.Sizes,
            orderMap   = vm.QtyMap,
            existingMap= vm.ExistingCut;

      function recalc() {
        let totalCalc=0, totalRemain=0;
        const ratios={}, plies={};
        document.querySelectorAll('.ratio-input').forEach(i=>{
          const d=i.dataset.docket, s=i.dataset.size, v=parseInt(i.value,10)||0;
          if(!ratios[d]) ratios[d]={};
          ratios[d][s]=v;
        });
        document.querySelectorAll('.plies-input').forEach(i=>{
          plies[i.dataset.docket]=parseInt(i.value,10)||0;
        });
        sizes.forEach(s=>{
          const ord = orderMap[s]||0,
                cut = existingMap[s]||0,
                used= Object.entries(ratios).reduce(
                   (sum,[d,map])=>sum + (map[s]||0)*(plies[d]||0),0),
                remain = ord - cut - used;
          document.getElementById(`calcQty_${s}`).textContent = used;
          const remEl = document.getElementById(`remainQty_${s}`);
          remEl.textContent = remain;
          remEl.style.color = remain>=0?'green':'red';
          totalCalc += used;
          totalRemain += remain;
        });
        document.getElementById('calcQtyTotal').textContent = totalCalc;
        const remTotEl = document.getElementById('remainQtyTotal');
        remTotEl.textContent = totalRemain;
        remTotEl.style.color = totalRemain>=0?'green':'red';
        // row‐totals = sum of ratios × plies
        Object.entries(ratios).forEach(([dock,map])=>{
          const sumRatios = Object.values(map).reduce((a,b)=>a+b,0),
                countPlies=plies[dock]||0,
                rowTotal  = sumRatios*countPlies,
                cell      = document.querySelector(`.row-total-size[data-docket="${dock}"]`);
          if(cell) cell.textContent = rowTotal;
        });
      }
      document.querySelectorAll('.ratio-input, .plies-input')
              .forEach(i=>i.addEventListener('input', recalc));
      recalc();
    }

    // PROPAGATION: “Totals” → plies, and marker‐name/size propagate length/width
    function setupPropagation() {
      document.querySelectorAll('.docket-total-input').forEach(i=>{
        i.addEventListener('input', ()=>{
          const d=i.dataset.docket,
                p=document.querySelector(`.plies-input[data-docket="${d}"]`);
          if(p){ p.value=i.value; p.dispatchEvent(new Event('input',{ bubbles:true })); }
        });
      });
      // marker‐name → enable length/width + copy across same names…
      document.querySelectorAll('.marker-name-input').forEach(i=>{
        i.addEventListener('input',()=>{
          const name=i.value.trim(), dock=i.dataset.docket,
                lenEl=document.querySelector(`.marker-length-input[data-docket="${dock}"]`),
                widEl=document.querySelector(`.marker-width-input[data-docket="${dock}"]`);
          const enabled=!!name;
          lenEl.disabled=widEl.disabled=!enabled;
          if(!enabled){
            lenEl.value=widEl.value=''; 
            lenEl.dispatchEvent(new Event('input',{ bubbles:true }));
            widEl.dispatchEvent(new Event('input',{ bubbles:true }));
            return;
          }
          document.querySelectorAll('.marker-name-input').forEach(o=>{
            if(o!==i && o.value.trim()===name){
              const od=o.dataset.docket,
                    srcLen=document.querySelector(`.marker-length-input[data-docket="${od}"]`).value,
                    srcWid=document.querySelector(`.marker-width-input[data-docket="${od}"]`).value;
              if(srcLen||srcWid){
                lenEl.value=srcLen; widEl.value=srcWid;
                lenEl.dispatchEvent(new Event('input',{ bubbles:true }));
                widEl.dispatchEvent(new Event('input',{ bubbles:true }));
              }
            }
          });
        });
      });
      // length & width true-user-input propagation
      document.querySelectorAll('.marker-length-input').forEach(i=>{
        i.addEventListener('input',e=>{
          if(!e.isTrusted) return;
          const dock=i.dataset.docket,
                name=document.querySelector(`.marker-name-input[data-docket="${dock}"]`).value.trim(),
                val=i.value;
          if(!name) return;
          document.querySelectorAll('.marker-length-input').forEach(o=>{
            const od=o.dataset.docket,
                  on=document.querySelector(`.marker-name-input[data-docket="${od}"]`).value.trim();
            if(od!==dock && on===name){
              o.value=val;
              o.dispatchEvent(new Event('input',{ bubbles:true }));
            }
          });
        });
      });
      document.querySelectorAll('.marker-width-input').forEach(i=>{
        i.addEventListener('input',e=>{
          if(!e.isTrusted) return;
          const dock=i.dataset.docket,
                name=document.querySelector(`.marker-name-input[data-docket="${dock}"]`).value.trim(),
                val=i.value;
          if(!name) return;
          document.querySelectorAll('.marker-width-input').forEach(o=>{
            const od=o.dataset.docket,
                  on=document.querySelector(`.marker-name-input[data-docket="${od}"]`).value.trim();
            if(od!==dock && on===name){
              o.value=val;
              o.dispatchEvent(new Event('input',{ bubbles:true }));
            }
          });
        });
      });
    }

    // CENTRAL CALCULATIONS: fabric requirement, usage, saving, target
    function setupCentralCalculation() {
      const vmScript = document.getElementById('matrix-data'),
            vm       = vmScript ? JSON.parse(vmScript.textContent)
                                : { Sizes: [], QtyMap:{}, ExistingCut:{} },
            sizes    = vm.Sizes;

      function recalc() {
        // reuse the recalc from buildPlanMatrixInit for row‐totals & qty
        buildPlanMatrixInit();
      }

      function calcFabric(dock) {
        const len   = parseFloat(document.querySelector(`.marker-length-input[data-docket="${dock}"]`).value)||0,
              allow = parseFloat(document.querySelector(`.allowance-input[data-docket="${dock}"]`).value)||0,
              ply   = parseInt(document.querySelector(`.plies-input[data-docket="${dock}"]`).value,10)||0,
              fab   = (len+allow)*ply,
              cell  = document.querySelector(`.fabric-req-cell[data-docket="${dock}"]`);
        if(cell) cell.textContent = fab.toFixed(3);
      }
      function calcUsage(dock) {
        const fab   = parseFloat(document.querySelector(`.fabric-req-cell[data-docket="${dock}"]`).textContent)||0,
              total = parseFloat(document.querySelector(`.row-total-size[data-docket="${dock}"]`).textContent)||0,
              usage = total>0?fab/total:0,
              cell  = document.querySelector(`.marker-usage-cell[data-docket="${dock}"]`);
        if(cell) cell.textContent = usage.toFixed(3);
      }
      function calcSaving(dock) {
        const bom   = parseFloat(document.querySelector(`.bom-usage-cell[data-docket="${dock}"]`).textContent)||0,
              usage = parseFloat(document.querySelector(`.marker-usage-cell[data-docket="${dock}"]`).textContent)||0,
              total = parseFloat(document.querySelector(`.row-total-size[data-docket="${dock}"]`).textContent)||0,
              saving= (bom-usage)*total,
              cell  = document.querySelector(`.marker-saving-cell[data-docket="${dock}"]`);
        if(cell) cell.textContent = saving.toFixed(3);
            }
            function calcTarget(dock) {
                const plies = parseInt(
                    document.querySelector(`.plies-input[data-docket="${dock}"]`).value,
                    10
                ) || 0;

                const cell = document.querySelector(`.target-length-cell[data-docket="${dock}"]`);
                if (plies <= 0) {
                    cell.textContent = '';
                    return;
                }

                const sumRatios = [...document.querySelectorAll(`.ratio-input[data-docket="${dock}"]`)]
                    .reduce((sum, inp) => sum + (parseInt(inp.value, 10) || 0), 0);

                const bom = parseFloat(
                    document.querySelector(`.bom-usage-cell[data-docket="${dock}"]`).textContent
                ) || 0;

                cell.textContent = (sumRatios * bom).toFixed(3);
            }

      function doAllCalculations() {
        recalc();
        document.querySelectorAll('.plies-input').forEach(i=>{
          const dock = i.dataset.docket;
          calcFabric(dock);
          calcUsage(dock);
          calcSaving(dock);
          calcTarget(dock);
        });
        // grand totals
        let totalFab=0, totalSave=0;
        document.querySelectorAll('.fabric-req-cell').forEach(c=> totalFab+=parseFloat(c.textContent)||0);
        document.querySelectorAll('.marker-saving-cell').forEach(c=> totalSave+=parseFloat(c.textContent)||0);
        const fabCell  = document.getElementById('fabricTotalCell'),
              saveCell = document.getElementById('markerSavingTotalCell');
        if(fabCell){ fabCell.textContent = totalFab.toFixed(3);  fabCell.style.color='blue'; }
        if(saveCell){ saveCell.textContent= totalSave.toFixed(3); saveCell.style.color='crimson'; }
      }

      // wire it up
      document.querySelectorAll('.ratio-input, .plies-input, .allowance-input, .marker-length-input')
        .forEach(i=>i.addEventListener('input', doAllCalculations));

              // ↴ ALSO: whenever a ratio changes (and plies > 0), recalc JUST that dock’s target
                  document.querySelectorAll('.ratio-input').forEach(input => {
                        input.addEventListener('input', () => {
                              const dock = input.dataset.docket;
                              const plies = parseInt(
                                    document.querySelector(`.plies-input[data-docket="${dock}"]`).value,
                                    10
                                  ) || 0;
                              if (plies > 0) {
                                    calcTarget(dock);
                                  }
                            });
                      });

      // initial run
      doAllCalculations();
    }

  </script>
}



